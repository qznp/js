<!--
 * @Descripttion: 函数
 * @Date: 2020-10-12 18:02:40
 * @LastEditTime: 2020-10-13 09:30:35
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
<script>
  // 一、什么是函数？
  // 函数就是一组能实现特定功能的代码段。只不过要实现这个功能，只需要调用函数名即可，不需要重写函数内部的功能代码。

  // 函数的使用场景？
  // 如果当前功能代码段仅仅会使用一次，则不需要使用函数，如果在多处都需要使用该代码段，则把代码包装在函数中，哪个地方用，就在哪个地方调用即可，大大节省代码成本

  // 定义函数的写法
  // function 函数名(参数) {
  //   函数体
  // }

  // 二、函数分类
  // 系统函数：有js语言体系提供的现成函数，程序员只需要调用执行即可，不需要定义这些函数。parseInt()
  // 自定义函数：需要自己定义或者封装、定义的函数就是自定义函数
  // 1、无参无返
  function sum1() {
    console.log(1);
  }
  sum1();
  // 2、有参无返
  // 形参：形式参数，用来接收调用函数时传递给改函数的参数
  function sum2(a,b) {
    console.log(a+b)
  }
  // 实参：实际参数，所用在调用函数时的小括号中所写参数就是实参
  // 参数传递方向：有实参传给形参
  // 参数传递的是变量的值，吧该实参的值拷贝一份给形参，在函数中操作的形参其实就是在操作实参的副本，形参的值变量什么样和实参没有关系
  sum2(1,2);
  // 3、有参有返
  function sum3(a,b) {
    var c = a + b;
    return c
  }
  var c = sum3(1,2);
  console.log(c);
  // 4、无参有返
  function sum4() {
    // return关键字作用
    // 1、终止当前函数继续执行，回到函数调用的位置，继续向后执行
    // 2、吧函数内部的数据传递到函数以外，这样调用执行函数结束之后，就可以收到传递的值
    return 1 + 2;
  } 
  console.log(sum4());

  // 三、变量作用域
  // 全局变量：一旦变量被定义出来之后，在任何位置都能访问到这个变量的值
  // 如何定义一个全局变量？
  // 定义变量的代码不属于任何函数，该变量就是全局变量
  // 局部变量：一旦这个变量被定义出来后，只能在有限范围的代码内才能访问到这个变量的值
  // 如何定义一个局部变量？
  // 在函数内部定义的变量就是局部变量，作用域（变量的有效范围）是当前函数
  // var a = 12;
  // function test() {
  //   console.log(a);
  //   var a = 24;
  //   console.log(a);
  //   a++;
  // }
  // test();
  // console.log(a);

  // 四、匿名函数
  // 匿名函数：没有函数名的函数，匿名函数除了没有函数名，函数调用和普通函数不一样外，其他地方和普通函数完全一样
  var a = function () {
    // alert('匿名函数')
  }
  console.log(a);
  // 把匿名函数的代码赋值给一个变量，该变量就相当于函数名，通过变量名+小括号的形式可以调用匿名函数
  a();
  // 匿名函数的使用场景
  // 1、把匿名函数当做事件函数使用，已达到节约代码的目的
  // 2、利用匿名函数自调用的形式老来创建块级作用域（局部作用域的变量），已达到及时释放不需要的内存空间，节约内存的目的
  (function () {
    // alert('匿名函数');
  })();

  // 五、函数的参数
  function hello(a,b,c) {
    console.log(a);
    console.log(b);
    console.log(c);
  }
  // hello(12,12,12);
  // 调用函数式实参个数少于形参的个数，少的那个为undefined
  // hello(1,1)
  // 调用函数时实参个数多于形参个数
  // hello(2,2,2,2,2,2,2);

  function bye() {
    // 如果在定义函数时没有声明形参列表，但是调用函数时该函数传了实参，则这些参数会按照顺序存放在arguments这个隐藏属性中，可以通过下标的形式依次获取到传来的值
    console.log(arguments)
  }
  // bye(12,12,12)

  // 六、递归
  // 什么事递归？
  // 函数不断的自己调用执行自己，当符合某个条件时，就停止调用
  function jie(n) {
    if (n === 1) {
      return 1;
    }
    return jie(n-1) * n;
  }
  var a = jie(3);
  console.log(111111111)
  console.log(a);
</script>
</html>